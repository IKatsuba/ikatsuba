<!DOCTYPE html><html lang="en"><head>
    <meta charset="utf-8">
    <title>Readme</title>
    <base href="/">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/x-icon" href="favicon.ico">
  <style>html{-moz-tab-size:4;tab-size:4;line-height:1.15;-webkit-text-size-adjust:100%;}body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji;}html{font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;line-height:1.5;}body{font-family:inherit;line-height:inherit;}*,:after,:before{box-sizing:border-box;border:0 solid #e5e7eb;}*{--tw-shadow:0 0 #0000;--tw-ring-inset:var(--tw-empty, );--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;}</style><style>html{-moz-tab-size:4;tab-size:4;line-height:1.15;-webkit-text-size-adjust:100%;}body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji;}hr{height:0;color:inherit;}strong{font-weight:bolder;}code,pre{font-family:ui-monospace,SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:1em;}figure,h1,h2,h3,hr,p,pre{margin:0;}ol,ul{margin:0;padding:0;}ol,ul{list-style:none;}html{font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;line-height:1.5;}body{font-family:inherit;line-height:inherit;}*,:after,:before{box-sizing:border-box;border:0 solid #e5e7eb;}hr{border-top-width:1px;}img{border-style:solid;}h1,h2,h3{font-size:inherit;font-weight:inherit;}a{color:inherit;text-decoration:inherit;}code,pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;}img{display:block;vertical-align:middle;}img{max-width:100%;height:auto;}.prose{color:#374151;max-width:65ch;}.prose a{color:#111827;text-decoration:underline;font-weight:500;}.prose strong{color:#111827;font-weight:600;}.prose ol>li{position:relative;padding-left:1.75em;}.prose ol>li:before{content:counter(list-item,var(--list-counter-style,decimal)) ".";position:absolute;font-weight:400;color:#6b7280;left:0;}.prose ul>li{position:relative;padding-left:1.75em;}.prose ul>li:before{content:"";position:absolute;background-color:#d1d5db;border-radius:50%;width:.375em;height:.375em;top:calc(.875em - .1875em);left:.25em;}.prose hr{border-color:#e5e7eb;border-top-width:1px;margin-top:3em;margin-bottom:3em;}.prose h1{color:#111827;font-weight:800;font-size:2.25em;margin-top:0;margin-bottom:.8888889em;line-height:1.1111111;}.prose h2{color:#111827;font-weight:700;font-size:1.5em;margin-top:2em;margin-bottom:1em;line-height:1.3333333;}.prose h3{font-size:1.25em;margin-top:1.6em;margin-bottom:.6em;line-height:1.6;}.prose h3{color:#111827;font-weight:600;}.prose code{color:#111827;font-weight:600;font-size:.875em;}.prose code:after,.prose code:before{content:"`";}.prose pre{color:#e5e7eb;background-color:#1f2937;overflow-x:auto;font-size:.875em;line-height:1.7142857;margin-top:1.7142857em;margin-bottom:1.7142857em;border-radius:.375rem;padding:.8571429em 1.1428571em;}.prose pre code{background-color:transparent;border-width:0;border-radius:0;padding:0;font-weight:400;color:inherit;font-size:inherit;font-family:inherit;line-height:inherit;}.prose pre code:after,.prose pre code:before{content:none;}.prose{font-size:1rem;line-height:1.75;}.prose p{margin-top:1.25em;margin-bottom:1.25em;}.prose figure,.prose img{margin-top:2em;margin-bottom:2em;}.prose figure>*{margin-top:0;margin-bottom:0;}.prose ol,.prose ul{margin-top:1.25em;margin-bottom:1.25em;}.prose li{margin-top:.5em;margin-bottom:.5em;}.prose>ol>li>:first-child{margin-top:1.25em;}.prose>ol>li>:last-child{margin-bottom:1.25em;}.prose h2+*,.prose h3+*,.prose hr+*{margin-top:0;}.prose>:first-child{margin-top:0;}.prose>:last-child{margin-bottom:0;}.prose-red a{color:#dc2626;}.rounded-full{border-radius:9999px;}.flex{display:flex;}.items-start{align-items:flex-start;}.text-4xl{font-size:2.25rem;line-height:2.5rem;}.m-auto{margin:auto;}.mb-1{margin-bottom:.25rem;}.mt-3{margin-top:.75rem;}.mt-6{margin-top:1.5rem;}.mb-6{margin-bottom:1.5rem;}.mr-8{margin-right:2rem;}.max-w-3xl{max-width:48rem;}*{--tw-shadow:0 0 #0000;--tw-ring-inset:var(--tw-empty, );--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;}.text-gray-500{--tw-text-opacity:1;color:rgba(107,114,128,var(--tw-text-opacity));}.text-gray-700{--tw-text-opacity:1;color:rgba(55,65,81,var(--tw-text-opacity));}.text-indigo-500{--tw-text-opacity:1;color:rgba(99,102,241,var(--tw-text-opacity));}.w-20{width:5rem;}@media (min-width: 1280px){.xl\:prose-xl{font-size:1.25rem;line-height:1.8;}.xl\:prose-xl p{margin-top:1.2em;margin-bottom:1.2em;}.xl\:prose-xl h1{font-size:2.8em;margin-top:0;margin-bottom:.8571429em;line-height:1;}.xl\:prose-xl h2{font-size:1.8em;margin-top:1.5555556em;margin-bottom:.8888889em;line-height:1.1111111;}.xl\:prose-xl h3{font-size:1.5em;margin-top:1.6em;margin-bottom:.6666667em;line-height:1.3333333;}.xl\:prose-xl figure,.xl\:prose-xl img{margin-top:2em;margin-bottom:2em;}.xl\:prose-xl figure>*{margin-top:0;margin-bottom:0;}.xl\:prose-xl code{font-size:.9em;}.xl\:prose-xl pre{font-size:.9em;line-height:1.7777778;margin-top:2em;margin-bottom:2em;border-radius:.5rem;padding:1.1111111em 1.3333333em;}.xl\:prose-xl ol,.xl\:prose-xl ul{margin-top:1.2em;margin-bottom:1.2em;}.xl\:prose-xl li{margin-top:.6em;margin-bottom:.6em;}.xl\:prose-xl ol>li{padding-left:1.8em;}.xl\:prose-xl ol>li:before{left:0;}.xl\:prose-xl ul>li{padding-left:1.8em;}.xl\:prose-xl ul>li:before{width:.35em;height:.35em;top:calc(.9em - .175em);left:.25em;}.xl\:prose-xl>ol>li>:first-child{margin-top:1.2em;}.xl\:prose-xl>ol>li>:last-child{margin-bottom:1.2em;}.xl\:prose-xl hr{margin-top:2.8em;margin-bottom:2.8em;}.xl\:prose-xl h2+*,.xl\:prose-xl h3+*,.xl\:prose-xl hr+*{margin-top:0;}.xl\:prose-xl>:first-child{margin-top:0;}.xl\:prose-xl>:last-child{margin-bottom:0;}}</style><link rel="stylesheet" href="styles.f598d9ba8020d5461c0a.css" media="print" onload="this.media='all'"><noscript><link rel="stylesheet" href="styles.f598d9ba8020d5461c0a.css"></noscript><style ng-transition="serverApp"></style></head>
  <body>
    <ikatsuba-root _nghost-sc11="" ng-version="12.2.3"><div _ngcontent-sc11="" class="flex items-start mt-6 mb-6 max-w-3xl m-auto"><img _ngcontent-sc11="" src="assets/iam.png" class="rounded-full w-20 mr-8"><div _ngcontent-sc11=""><h2 _ngcontent-sc11="" class="text-gray-700 text-4xl mt-3 mb-1">Igor Katsuba</h2><p _ngcontent-sc11="" class="text-gray-500"> Angular Researcher / Working at <a _ngcontent-sc11="" href="https://twitter.com/ItsTinkoff" target="_blank" class="text-indigo-500">ItsTinkoff</a> / Author at <a _ngcontent-sc11="" href="https://indepth.dev/" target="_blank" class="text-indigo-500">indepth.dev</a></p></div></div><section _ngcontent-sc11="" class="prose xl:prose-xl prose-red m-auto"><hr _ngcontent-sc11=""><h1 _ngcontent-sc11="">Angular Universal: real app problems</h1><figure _ngcontent-sc11=""><img _ngcontent-sc11="" src="assets/angular-universal.png"></figure><p _ngcontent-sc11=""><strong _ngcontent-sc11="">Angular Universal</strong> is an open-source project that extends the functionality of <code _ngcontent-sc11="">@angular/platform-server</code>. The project makes server-side rendering possible in Angular. </p><p _ngcontent-sc11="">Angular Universal supports multiple backends:</p><ol _ngcontent-sc11=""><li _ngcontent-sc11=""><a _ngcontent-sc11="" href="https://github.com/angular/universal/blob/master/modules/express-engine/README.md">Express</a></li><li _ngcontent-sc11=""><a _ngcontent-sc11="" href="https://github.com/angular/universal/blob/master/modules/aspnetcore-engine/README.md">ASP.NET Core</a></li><li _ngcontent-sc11=""><a _ngcontent-sc11="" href="https://github.com/angular/universal/blob/master/modules/hapi-engine/README.md">hapi</a></li></ol><p _ngcontent-sc11=""> Another package <a _ngcontent-sc11="" href="https://github.com/angular/universal/tree/master/modules/socket-engine">Socket Engine</a> is a framework-agnostic that theoretically allows any backend to be connected to an SSR-server. </p><p _ngcontent-sc11=""> This article will discuss the issues and possible solutions we encountered while developing a real application with Angular Universal and Express. </p><hr _ngcontent-sc11=""><h1 _ngcontent-sc11="">How Angular Universal Works</h1><p _ngcontent-sc11=""> For rendering on the server, Angular uses the DOM implementation for node.js — <a _ngcontent-sc11="" href="https://www.npmjs.com/package/domino">domino</a>. For each GET request, <code _ngcontent-sc11="">domino</code> creates a similar Browser Document object. In that object context, Angular initializes the application. </p><p _ngcontent-sc11=""> The app makes requests to the backend, performs various asynchronous tasks, and applies any change detection from components to the DOM while still running inside node.js environment. The render engine then serializes DOM into a string and serves up the string to the server. The server sends this HTML as a response to the GET request. Angular application on the server is destroyed after rendering. </p><hr _ngcontent-sc11=""><h1 _ngcontent-sc11="">SSR issues in Angular</h1><h2 _ngcontent-sc11="">1. Infinite page loading</h2><h3 _ngcontent-sc11="">Situation</h3><p _ngcontent-sc11=""> The user opens a page on your site and sees a white screen. In other words, the time until the first byte takes too long. The browser wants to receive a response from the server, but the request ends up with a timeout. </p><h3 _ngcontent-sc11="">Why is this happening</h3><p _ngcontent-sc11=""> Most likely, the problem lies in the Angular-specific SSR mechanism. Before we understand at what point the page is rendered, let's define Zone.js and ApplicationRef. </p><p _ngcontent-sc11=""><a _ngcontent-sc11="" href="https://indepth.dev/posts/1059/do-you-still-think-that-ngzone-zone-js-is-required-for-change-detection-in-angular"><strong _ngcontent-sc11="">Zone.js</strong></a> is a tool that allows you to track asynchronous operations. With its help, Angular creates its zone and launches the application in it. At the end of each asynchronous operation in the Angular zone, change detection is triggered. </p><p _ngcontent-sc11=""><strong _ngcontent-sc11="">ApplicationRef</strong> is a reference to the running application (<a _ngcontent-sc11="" href="https://angular.io/api/core/ApplicationRef">docs</a>). Of all this class's functionality, we are interested in the <a _ngcontent-sc11="" href="https://angular.io/api/core/ApplicationRef#isStable">ApplicationRef#isStable</a> property. It is an Observable that emits a boolean. isStable is true when no asynchronous tasks are running in the Angular zone and false when there are any. </p><p _ngcontent-sc11=""><strong _ngcontent-sc11="">So, application stability is the state of the application, which depends on the presence of asynchronous tasks in the Angular zone.</strong></p><p _ngcontent-sc11=""> So, at the moment of <a _ngcontent-sc11="" href="https://github.com/angular/angular/blob/11.1.x/packages/platform-server/src/utils.ts#L43">the first onset of stability</a>, Angular <a _ngcontent-sc11="" href="https://github.com/angular/angular/blob/11.1.x/packages/platform-server/src/utils.ts#L69">renders the current state</a> applications and <a _ngcontent-sc11="" href="https://github.com/angular/angular/blob/11.1.x/packages/platform-server/src/utils.ts#L70">destroys the platform</a>. And the platform will destroy the application. </p><p _ngcontent-sc11=""> Now we can assume that the user is trying to open an application that cannot achieve stability. setInterval, rxjs.interval or any other recursive asynchronous operation running in the Angular zone will make stability impossible. HTTP requests also affect stability. The lingering request on the server delays the moment the page is rendered. </p><h3 _ngcontent-sc11="">Possible Solution</h3><p _ngcontent-sc11=""> To avoid the situation with long requests, use the timeout operator from rxjs library: </p><pre _ngcontent-sc11=""><code _ngcontent-sc11="" class="code-highlighted code-tsx"><span _ngcontent-sc11="" class="syntax-all syntax-keyword">import</span> { <span _ngcontent-sc11="" class="syntax-all syntax-parameter">timeout</span>, <span _ngcontent-sc11="" class="syntax-all syntax-parameter">catchError</span> } <span _ngcontent-sc11="" class="syntax-all syntax-keyword">from</span> <span _ngcontent-sc11="" class="syntax-all syntax-string">'rxjs/operators'</span>;
<span _ngcontent-sc11="" class="syntax-all syntax-keyword">import</span> { <span _ngcontent-sc11="" class="syntax-all syntax-parameter">of</span> } <span _ngcontent-sc11="" class="syntax-all syntax-keyword">from</span> <span _ngcontent-sc11="" class="syntax-all syntax-string">'rxjs/observable/of'</span>;

<span _ngcontent-sc11="" class="syntax-all syntax-parameter">http</span>.<span _ngcontent-sc11="" class="syntax-all syntax-constant">get</span>(<span _ngcontent-sc11="" class="syntax-all syntax-string">'https://example.com'</span>)
	.<span _ngcontent-sc11="" class="syntax-all syntax-entity">pipe</span>(
		<span _ngcontent-sc11="" class="syntax-all syntax-entity">timeout</span>(<span _ngcontent-sc11="" class="syntax-all syntax-constant">2000</span>),
		<span _ngcontent-sc11="" class="syntax-all syntax-entity">catchError</span>(<span _ngcontent-sc11="" class="syntax-all syntax-variable">e</span> <span _ngcontent-sc11="" class="syntax-all syntax-keyword">=&gt;</span> <span _ngcontent-sc11="" class="syntax-all syntax-keyword">of</span>(<span _ngcontent-sc11="" class="syntax-all syntax-constant">null</span>))
	).<span _ngcontent-sc11="" class="syntax-all syntax-entity">subscribe</span>()</code></pre><p _ngcontent-sc11=""> The operator will throw an exception after a specified if no server response is received. </p><p _ngcontent-sc11="">This approach has 2 cons:</p><ul _ngcontent-sc11=""><li _ngcontent-sc11="">There is no convenient division of logic by platform.</li><li _ngcontent-sc11="">The timeout operator must be written manually for each request.</li></ul><p _ngcontent-sc11=""> As a more straightforward solution, you can use the NgxSsrTimeoutModule module from the <a _ngcontent-sc11="" href="https://github.com/IKatsuba/ngx-ssr">@ngx-ssr/timeout</a> package. Import the module with the timeout value into the root module of the application. If the module is imported into AppServerModule, then HTTP request timeouts will only work for the server. </p><pre _ngcontent-sc11=""><code _ngcontent-sc11="" class="code-highlighted code-tsx"><span _ngcontent-sc11="" class="syntax-all syntax-keyword">import</span> { <span _ngcontent-sc11="" class="syntax-all syntax-parameter">NgModule</span> } <span _ngcontent-sc11="" class="syntax-all syntax-keyword">from</span> <span _ngcontent-sc11="" class="syntax-all syntax-string">'@angular/core'</span>;
<span _ngcontent-sc11="" class="syntax-all syntax-keyword">import</span> {
	<span _ngcontent-sc11="" class="syntax-all syntax-parameter">ServerModule</span>,
    } <span _ngcontent-sc11="" class="syntax-all syntax-keyword">from</span> <span _ngcontent-sc11="" class="syntax-all syntax-string">'@angular/platform-server'</span>;
<span _ngcontent-sc11="" class="syntax-all syntax-keyword">import</span> { <span _ngcontent-sc11="" class="syntax-all syntax-parameter">AppModule</span> } <span _ngcontent-sc11="" class="syntax-all syntax-keyword">from</span> <span _ngcontent-sc11="" class="syntax-all syntax-string">'./app.module'</span>;
<span _ngcontent-sc11="" class="syntax-all syntax-keyword">import</span> { <span _ngcontent-sc11="" class="syntax-all syntax-parameter">AppComponent</span> } <span _ngcontent-sc11="" class="syntax-all syntax-keyword">from</span> <span _ngcontent-sc11="" class="syntax-all syntax-string">'./app.component'</span>;
<span _ngcontent-sc11="" class="syntax-all syntax-keyword">import</span> { <span _ngcontent-sc11="" class="syntax-all syntax-parameter">NgxSsrTimeoutModule</span> } <span _ngcontent-sc11="" class="syntax-all syntax-keyword">from</span> <span _ngcontent-sc11="" class="syntax-all syntax-string">'@ngx-ssr/timeout'</span>;

@<span _ngcontent-sc11="" class="syntax-all syntax-entity">NgModule</span>({
    imports: [
      <span _ngcontent-sc11="" class="syntax-all syntax-parameter">AppModule</span>,
      <span _ngcontent-sc11="" class="syntax-all syntax-parameter">ServerModule</span>,
      <span _ngcontent-sc11="" class="syntax-all syntax-parameter">NgxSsrTimeoutModule</span>.<span _ngcontent-sc11="" class="syntax-all syntax-entity">forRoot</span>({ timeout: <span _ngcontent-sc11="" class="syntax-all syntax-constant">500</span> }),
	],
	bootstrap: [<span _ngcontent-sc11="" class="syntax-all syntax-parameter">AppComponent</span>],
})
<span _ngcontent-sc11="" class="syntax-all syntax-keyword">export</span> <span _ngcontent-sc11="" class="syntax-all syntax-keyword">class</span> <span _ngcontent-sc11="" class="syntax-all syntax-entity">AppServerModule</span> {}</code></pre><p _ngcontent-sc11=""> Use the <a _ngcontent-sc11="" href="https://angular.io/api/core/NgZone">NgZone</a> service to take asynchronous operations out of the Angular zone. </p><pre _ngcontent-sc11=""><code _ngcontent-sc11="" class="code-highlighted code-tsx"><span _ngcontent-sc11="" class="syntax-all syntax-keyword">import</span> { <span _ngcontent-sc11="" class="syntax-all syntax-parameter">Injectable</span>, <span _ngcontent-sc11="" class="syntax-all syntax-parameter">NgZone</span> } <span _ngcontent-sc11="" class="syntax-all syntax-keyword">from</span> <span _ngcontent-sc11="" class="syntax-all syntax-string">"@angular/core"</span>;

@<span _ngcontent-sc11="" class="syntax-all syntax-entity">Injectable</span>()
<span _ngcontent-sc11="" class="syntax-all syntax-keyword">export</span> <span _ngcontent-sc11="" class="syntax-all syntax-keyword">class</span> <span _ngcontent-sc11="" class="syntax-all syntax-entity">SomeService</span> {
    <span _ngcontent-sc11="" class="syntax-all syntax-keyword">constructor</span>(<span _ngcontent-sc11="" class="syntax-all syntax-keyword">private</span> <span _ngcontent-sc11="" class="syntax-all syntax-variable">ngZone</span><span _ngcontent-sc11="" class="syntax-all syntax-keyword">:</span> <span _ngcontent-sc11="" class="syntax-all syntax-entity">NgZone</span>){
		<span _ngcontent-sc11="" class="syntax-all syntax-constant">this</span>.<span _ngcontent-sc11="" class="syntax-all syntax-parameter">ngZone</span>.<span _ngcontent-sc11="" class="syntax-all syntax-entity">runOutsideAngular</span>(() <span _ngcontent-sc11="" class="syntax-all syntax-keyword">=&gt;</span> {
    <span _ngcontent-sc11="" class="syntax-all syntax-entity">interval</span>(<span _ngcontent-sc11="" class="syntax-all syntax-constant">1</span>).<span _ngcontent-sc11="" class="syntax-all syntax-entity">subscribe</span>(() <span _ngcontent-sc11="" class="syntax-all syntax-keyword">=&gt;</span> {
				<span _ngcontent-sc11="" class="syntax-all syntax-comment">// somo code
</span>			})
		});
	}
}</code></pre><p _ngcontent-sc11=""> To solve this problem, you can use the <a _ngcontent-sc11="" href="https://github.com/TinkoffCreditSystems/taiga-ui/blob/main/projects/cdk/observables/zone-free.ts#L30">tuiZonefree</a> from the <code _ngcontent-sc11="">@taiga-ui/cdk</code>: </p><pre _ngcontent-sc11=""><code _ngcontent-sc11="" class="code-highlighted code-tsx"><span _ngcontent-sc11="" class="syntax-all syntax-keyword">import</span> { <span _ngcontent-sc11="" class="syntax-all syntax-parameter">Injectable</span>, <span _ngcontent-sc11="" class="syntax-all syntax-parameter">NgZone</span> } <span _ngcontent-sc11="" class="syntax-all syntax-keyword">from</span> <span _ngcontent-sc11="" class="syntax-all syntax-string">"@angular/core"</span>;
<span _ngcontent-sc11="" class="syntax-all syntax-keyword">import</span> { <span _ngcontent-sc11="" class="syntax-all syntax-parameter">tuiZonefree</span> } <span _ngcontent-sc11="" class="syntax-all syntax-keyword">from</span> <span _ngcontent-sc11="" class="syntax-all syntax-string">"@taiga-ui/cdk"</span>;

@<span _ngcontent-sc11="" class="syntax-all syntax-entity">Injectable</span>()
<span _ngcontent-sc11="" class="syntax-all syntax-keyword">export</span> <span _ngcontent-sc11="" class="syntax-all syntax-keyword">class</span> <span _ngcontent-sc11="" class="syntax-all syntax-entity">SomeService</span> {
    <span _ngcontent-sc11="" class="syntax-all syntax-keyword">constructor</span>(<span _ngcontent-sc11="" class="syntax-all syntax-keyword">private</span> <span _ngcontent-sc11="" class="syntax-all syntax-variable">ngZone</span><span _ngcontent-sc11="" class="syntax-all syntax-keyword">:</span> <span _ngcontent-sc11="" class="syntax-all syntax-entity">NgZone</span>){
		<span _ngcontent-sc11="" class="syntax-all syntax-entity">interval</span>(<span _ngcontent-sc11="" class="syntax-all syntax-constant">1</span>).<span _ngcontent-sc11="" class="syntax-all syntax-entity">pipe</span>(<span _ngcontent-sc11="" class="syntax-all syntax-entity">tuiZonefree</span>(<span _ngcontent-sc11="" class="syntax-all syntax-parameter">ngZone</span>)).<span _ngcontent-sc11="" class="syntax-all syntax-entity">subscribe</span>()
	}
}</code></pre><p _ngcontent-sc11=""> But there is a nuance. Any task must be interrupted when the application is destroyed. Otherwise, you can catch a memory leak (see issue #5). You also need to understand that tasks that are removed from the zone will not trigger change detection. </p><h2 _ngcontent-sc11="">2. Lack of cache out of the box</h2><h3 _ngcontent-sc11="">Situation</h3><p _ngcontent-sc11=""> The user loads the home page of the site. The server requests data for the master and renders it, spending 2 seconds on it. Then the user goes from the main to the child section. Then it tries to go back and waits for the same 2 seconds as the first time. </p><p _ngcontent-sc11=""> If we assume that the data on which the main render depends has not changed, it turns out that HTML with this set has already been rendered. And in theory, we can reuse the HTML we got earlier. </p><h3 _ngcontent-sc11="">Possible Solution</h3><p _ngcontent-sc11=""> Various caching techniques come to the rescue. We'll cover two: in-memory cache and HTTP cache. </p><p _ngcontent-sc11=""><strong _ngcontent-sc11="">HTTP cache.</strong> When using a network cache, it's all about setting the correct response headers on the server. They specify the cache lifetime and caching policy: </p><pre _ngcontent-sc11=""><code _ngcontent-sc11="" class="code-highlighted code-tsx"><span _ngcontent-sc11="" class="syntax-all syntax-parameter">Cache</span><span _ngcontent-sc11="" class="syntax-all syntax-keyword">-</span><span _ngcontent-sc11="" class="syntax-all syntax-parameter">Control</span>: <span _ngcontent-sc11="" class="syntax-all syntax-parameter">max</span><span _ngcontent-sc11="" class="syntax-all syntax-keyword">-</span><span _ngcontent-sc11="" class="syntax-all syntax-parameter">age</span> <span _ngcontent-sc11="" class="syntax-all syntax-keyword">=</span> <span _ngcontent-sc11="" class="syntax-all syntax-constant">31536000</span></code></pre><p _ngcontent-sc11=""> This option is suitable for an unauthorized zone and in the presence of long unchanging data. </p><p _ngcontent-sc11=""> You can read more about the HTTP cache <a _ngcontent-sc11="" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching">here</a></p><p _ngcontent-sc11=""><strong _ngcontent-sc11="">In-memory cache.</strong> The in-memory cache can be used for both rendered pages and API requests within the application itself. Both possibilities are package <code _ngcontent-sc11="">@ngx-ssr/cache</code>. </p><p _ngcontent-sc11=""> Add the NgxSsrCacheModule module to the AppModule to cache API requests and on the server in the browser. </p><p _ngcontent-sc11=""> The <code _ngcontent-sc11="">maxSize</code> property is responsible for the maximum cache size. A value of 50 means that the cache will contain more than 50 of the last GET requests made from the application. </p><p _ngcontent-sc11=""> The <code _ngcontent-sc11="">maxAge</code> property is responsible for the cache lifetime. Specified in milliseconds. </p><pre _ngcontent-sc11=""><code _ngcontent-sc11="" class="code-highlighted code-tsx"><span _ngcontent-sc11="" class="syntax-all syntax-keyword">import</span> { <span _ngcontent-sc11="" class="syntax-all syntax-parameter">BrowserModule</span> } <span _ngcontent-sc11="" class="syntax-all syntax-keyword">from</span> <span _ngcontent-sc11="" class="syntax-all syntax-string">'@angular/platform-browser'</span>;
<span _ngcontent-sc11="" class="syntax-all syntax-keyword">import</span> { <span _ngcontent-sc11="" class="syntax-all syntax-parameter">NgModule</span> } <span _ngcontent-sc11="" class="syntax-all syntax-keyword">from</span> <span _ngcontent-sc11="" class="syntax-all syntax-string">'@angular/core'</span>;
<span _ngcontent-sc11="" class="syntax-all syntax-keyword">import</span> { <span _ngcontent-sc11="" class="syntax-all syntax-parameter">AppComponent</span> } <span _ngcontent-sc11="" class="syntax-all syntax-keyword">from</span> <span _ngcontent-sc11="" class="syntax-all syntax-string">'./app.component'</span>;
<span _ngcontent-sc11="" class="syntax-all syntax-keyword">import</span> { <span _ngcontent-sc11="" class="syntax-all syntax-parameter">NgxSsrCacheModule</span> } <span _ngcontent-sc11="" class="syntax-all syntax-keyword">from</span> <span _ngcontent-sc11="" class="syntax-all syntax-string">'@ngx-ssr/cache'</span>;
<span _ngcontent-sc11="" class="syntax-all syntax-keyword">import</span> { <span _ngcontent-sc11="" class="syntax-all syntax-parameter">environment</span> } <span _ngcontent-sc11="" class="syntax-all syntax-keyword">from</span> <span _ngcontent-sc11="" class="syntax-all syntax-string">'../environments/environment'</span>;

@<span _ngcontent-sc11="" class="syntax-all syntax-entity">NgModule</span>({
    declarations: [<span _ngcontent-sc11="" class="syntax-all syntax-parameter">AppComponent</span>],
    imports: [
      <span _ngcontent-sc11="" class="syntax-all syntax-parameter">BrowserModule</span>,
      <span _ngcontent-sc11="" class="syntax-all syntax-parameter">NgxSsrCacheModule</span>.<span _ngcontent-sc11="" class="syntax-all syntax-entity">configLruCache</span>({ maxAge: <span _ngcontent-sc11="" class="syntax-all syntax-constant">10</span> <span _ngcontent-sc11="" class="syntax-all syntax-keyword">*</span> <span _ngcontent-sc11="" class="syntax-all syntax-constant">60_000</span>, maxSize: <span _ngcontent-sc11="" class="syntax-all syntax-constant">50</span> }),
	],
	bootstrap: [<span _ngcontent-sc11="" class="syntax-all syntax-parameter">AppComponent</span>],
})
<span _ngcontent-sc11="" class="syntax-all syntax-keyword">export</span> <span _ngcontent-sc11="" class="syntax-all syntax-keyword">class</span> <span _ngcontent-sc11="" class="syntax-all syntax-entity">AppModule</span> {}</code></pre><p _ngcontent-sc11="">You can go ahead and cache the HTML itself.</p><p _ngcontent-sc11=""> For example, everything in the same package <code _ngcontent-sc11="">@ngx-ssr/cache</code> has a submodule <code _ngcontent-sc11="">@ngx-ssr/cache/express</code>. It imports a single <code _ngcontent-sc11="">withCache</code> function. The function is a wrapper over the render engine. </p><pre _ngcontent-sc11=""><code _ngcontent-sc11="" class="code-highlighted code-tsx"><span _ngcontent-sc11="" class="syntax-all syntax-keyword">import</span> { <span _ngcontent-sc11="" class="syntax-all syntax-parameter">ngExpressEngine</span> } <span _ngcontent-sc11="" class="syntax-all syntax-keyword">from</span> <span _ngcontent-sc11="" class="syntax-all syntax-string">'@nguniversal/express-engine'</span>;
      <span _ngcontent-sc11="" class="syntax-all syntax-keyword">import</span> { <span _ngcontent-sc11="" class="syntax-all syntax-parameter">LRUCache</span> } <span _ngcontent-sc11="" class="syntax-all syntax-keyword">from</span> <span _ngcontent-sc11="" class="syntax-all syntax-string">'@ngx-ssr/cache'</span>;
      <span _ngcontent-sc11="" class="syntax-all syntax-keyword">import</span> { <span _ngcontent-sc11="" class="syntax-all syntax-parameter">withCache</span> } <span _ngcontent-sc11="" class="syntax-all syntax-keyword">from</span> <span _ngcontent-sc11="" class="syntax-all syntax-string">'@ngx-ssr/cache/express'</span>;

      <span _ngcontent-sc11="" class="syntax-all syntax-parameter">server</span>.<span _ngcontent-sc11="" class="syntax-all syntax-entity">engine</span>(
      <span _ngcontent-sc11="" class="syntax-all syntax-string">'html'</span>,
      <span _ngcontent-sc11="" class="syntax-all syntax-entity">withCache</span>(
      <span _ngcontent-sc11="" class="syntax-all syntax-keyword">new</span> <span _ngcontent-sc11="" class="syntax-all syntax-entity">LRUCache</span>({ maxAge: <span _ngcontent-sc11="" class="syntax-all syntax-constant">10</span> <span _ngcontent-sc11="" class="syntax-all syntax-keyword">*</span> <span _ngcontent-sc11="" class="syntax-all syntax-constant">60_000</span>, maxSize: <span _ngcontent-sc11="" class="syntax-all syntax-constant">100</span> }),
		<span _ngcontent-sc11="" class="syntax-all syntax-entity">ngExpressEngine</span>({
			bootstrap: <span _ngcontent-sc11="" class="syntax-all syntax-parameter">AppServerModule</span>,
      })
	)
);</code></pre><h2 _ngcontent-sc11="">3. Server errors of type ReferenceError: localStorage is not defined</h2><h3 _ngcontent-sc11="">Situation</h3><p _ngcontent-sc11=""> The developer calls localStorage right in the body of the service. It retrieves data from the local storage by key. But on the server, this code crashes with an error: ReferenceError: localStorage is undefined. </p><h3 _ngcontent-sc11="">Why is this happening</h3><p _ngcontent-sc11=""> When running an Angular application on a server, the standard browser API is missing from the global space. For example, there's no global object <code _ngcontent-sc11="">document</code> like you'd expect in a browser environment. To get the reference to the document, you must use the DOCUMENT token and DI. </p><h3 _ngcontent-sc11="">Possible Solution</h3><p _ngcontent-sc11=""> Don't use the browser API through the global space. There is DI for this. Through DI, you can replace or disable browser implementations for their safe use on the server. </p><p _ngcontent-sc11=""> The <a _ngcontent-sc11="" href="https://ng-web-apis.github.io/">Web API for Angular</a> can be used to resolve this issue. </p><p _ngcontent-sc11="">For example:</p><pre _ngcontent-sc11=""><code _ngcontent-sc11="" class="code-highlighted code-tsx"><span _ngcontent-sc11="" class="syntax-all syntax-keyword">import</span> {<span _ngcontent-sc11="" class="syntax-all syntax-parameter">Component</span>, <span _ngcontent-sc11="" class="syntax-all syntax-parameter">Inject</span>, <span _ngcontent-sc11="" class="syntax-all syntax-parameter">NgModule</span>} <span _ngcontent-sc11="" class="syntax-all syntax-keyword">from</span> <span _ngcontent-sc11="" class="syntax-all syntax-string">'@angular/core'</span>;
<span _ngcontent-sc11="" class="syntax-all syntax-keyword">import</span> {<span _ngcontent-sc11="" class="syntax-all syntax-parameter">LOCAL_STORAGE</span>} <span _ngcontent-sc11="" class="syntax-all syntax-keyword">from</span> <span _ngcontent-sc11="" class="syntax-all syntax-string">'@ng-web-apis/common'</span>;

@<span _ngcontent-sc11="" class="syntax-all syntax-entity">Component</span>({<span _ngcontent-sc11="" class="syntax-all syntax-keyword">...</span>})
<span _ngcontent-sc11="" class="syntax-all syntax-keyword">export</span> <span _ngcontent-sc11="" class="syntax-all syntax-keyword">class</span> <span _ngcontent-sc11="" class="syntax-all syntax-entity">SomeComponent</span> {
    <span _ngcontent-sc11="" class="syntax-all syntax-keyword">constructor</span>(@<span _ngcontent-sc11="" class="syntax-all syntax-entity">Inject</span>(<span _ngcontent-sc11="" class="syntax-all syntax-constant">LOCAL_STORAGE</span>) <span _ngcontent-sc11="" class="syntax-all syntax-variable">localStorage</span><span _ngcontent-sc11="" class="syntax-all syntax-keyword">:</span> <span _ngcontent-sc11="" class="syntax-all syntax-entity">Storage</span>) {
		<span _ngcontent-sc11="" class="syntax-all syntax-parameter">localStorage</span>.<span _ngcontent-sc11="" class="syntax-all syntax-constant">getItem</span>(<span _ngcontent-sc11="" class="syntax-all syntax-string">'key'</span>);
	}
}</code></pre><p _ngcontent-sc11=""> The example above uses the <code _ngcontent-sc11="">LOCAL_STORAGE</code> token from the <a _ngcontent-sc11="" href="https://github.com/ng-web-apis/common#tokens">@ng-web-apis/common</a> package. But when we run this code on the server, we will get an error from the description. Just add <code _ngcontent-sc11="">UNIVERSAL_LOCAL_STORAGE</code> from the package <a _ngcontent-sc11="" href="https://github.com/ng-web-apis/universal">@ng-web-apis/universal</a> in the providers <code _ngcontent-sc11="">AppServerModule</code>, and by the token <code _ngcontent-sc11="">LOCAL_STORAGE</code>, you will receive an implementation of localStorage for the server. </p><pre _ngcontent-sc11=""><code _ngcontent-sc11="" class="code-highlighted code-tsx"><span _ngcontent-sc11="" class="syntax-all syntax-keyword">import</span> { <span _ngcontent-sc11="" class="syntax-all syntax-parameter">NgModule</span> } <span _ngcontent-sc11="" class="syntax-all syntax-keyword">from</span> <span _ngcontent-sc11="" class="syntax-all syntax-string">'@angular/core'</span>;
<span _ngcontent-sc11="" class="syntax-all syntax-keyword">import</span> {
    <span _ngcontent-sc11="" class="syntax-all syntax-parameter">ServerModule</span>,
} <span _ngcontent-sc11="" class="syntax-all syntax-keyword">from</span> <span _ngcontent-sc11="" class="syntax-all syntax-string">'@angular/platform-server'</span>;
<span _ngcontent-sc11="" class="syntax-all syntax-keyword">import</span> { <span _ngcontent-sc11="" class="syntax-all syntax-parameter">AppModule</span> } <span _ngcontent-sc11="" class="syntax-all syntax-keyword">from</span> <span _ngcontent-sc11="" class="syntax-all syntax-string">'./app.module'</span>;
<span _ngcontent-sc11="" class="syntax-all syntax-keyword">import</span> { <span _ngcontent-sc11="" class="syntax-all syntax-parameter">AppComponent</span> } <span _ngcontent-sc11="" class="syntax-all syntax-keyword">from</span> <span _ngcontent-sc11="" class="syntax-all syntax-string">'./app.component'</span>;
<span _ngcontent-sc11="" class="syntax-all syntax-keyword">import</span> { <span _ngcontent-sc11="" class="syntax-all syntax-parameter">UNIVERSAL_LOCAL_STORAGE</span> } <span _ngcontent-sc11="" class="syntax-all syntax-keyword">from</span> <span _ngcontent-sc11="" class="syntax-all syntax-string">'@ngx-ssr/timeout'</span>;

@<span _ngcontent-sc11="" class="syntax-all syntax-entity">NgModule</span>({
    imports: [
      <span _ngcontent-sc11="" class="syntax-all syntax-parameter">AppModule</span>,
      <span _ngcontent-sc11="" class="syntax-all syntax-parameter">ServerModule</span>,
    ],
    providers: [<span _ngcontent-sc11="" class="syntax-all syntax-constant">UNIVERSAL_LOCAL_STORAGE</span>],
    bootstrap: [<span _ngcontent-sc11="" class="syntax-all syntax-parameter">AppComponent</span>],
})
<span _ngcontent-sc11="" class="syntax-all syntax-keyword">export</span> <span _ngcontent-sc11="" class="syntax-all syntax-keyword">class</span> <span _ngcontent-sc11="" class="syntax-all syntax-entity">AppServerModule</span> {}</code></pre><h2 _ngcontent-sc11="">4. Inconvenient separation of logic</h2><h3 _ngcontent-sc11="">Situation</h3><p _ngcontent-sc11=""> If you need to render the block only in the browser, you need to write approximately the following code: </p><pre _ngcontent-sc11=""><code _ngcontent-sc11="" class="code-highlighted code-tsx">@<span _ngcontent-sc11="" class="syntax-all syntax-entity">Component</span>({
    selector: <span _ngcontent-sc11="" class="syntax-all syntax-string">'ram-root'</span>,
	template: <span _ngcontent-sc11="" class="syntax-all syntax-string">'&lt;some-сomp *ngIf="isServer"&gt;&lt;/some-сomp&gt;'</span>,
	styleUrls: [<span _ngcontent-sc11="" class="syntax-all syntax-string">'./app.component.less'</span>],
})
<span _ngcontent-sc11="" class="syntax-all syntax-keyword">export</span> <span _ngcontent-sc11="" class="syntax-all syntax-keyword">class</span> <span _ngcontent-sc11="" class="syntax-all syntax-entity">AppComponent</span> {
      isServer <span _ngcontent-sc11="" class="syntax-all syntax-keyword">=</span> <span _ngcontent-sc11="" class="syntax-all syntax-entity">isPlatformServer</span>(<span _ngcontent-sc11="" class="syntax-all syntax-constant">this</span>.<span _ngcontent-sc11="" class="syntax-all syntax-parameter">platformId</span>);

        <span _ngcontent-sc11="" class="syntax-all syntax-keyword">constructor</span>(@<span _ngcontent-sc11="" class="syntax-all syntax-entity">Inject</span>(<span _ngcontent-sc11="" class="syntax-all syntax-constant">PLATFORM_ID</span>) <span _ngcontent-sc11="" class="syntax-all syntax-keyword">private</span> <span _ngcontent-sc11="" class="syntax-all syntax-variable">platformId</span><span _ngcontent-sc11="" class="syntax-all syntax-keyword">:</span> <span _ngcontent-sc11="" class="syntax-all syntax-entity">Object</span>){}
        }</code></pre><p _ngcontent-sc11=""> The component needs to get the <code _ngcontent-sc11="">PLATFORM_ID</code>, target platform, and understand the class's public property. This property will be used in the template in conjunction with the <code _ngcontent-sc11="">ngIf</code> directive. </p><h3 _ngcontent-sc11="">Possible Solution</h3><p _ngcontent-sc11=""> With the help of structural directives and DI, the above mechanism can be greatly simplified. </p><p _ngcontent-sc11="">First, let's wrap the server definition in a token.</p><pre _ngcontent-sc11=""><code _ngcontent-sc11="" class="code-highlighted code-tsx"><span _ngcontent-sc11="" class="syntax-all syntax-keyword">export</span> <span _ngcontent-sc11="" class="syntax-all syntax-keyword">const</span> IS_SERVER_PLATFORM <span _ngcontent-sc11="" class="syntax-all syntax-keyword">=</span> <span _ngcontent-sc11="" class="syntax-all syntax-keyword">new</span> <span _ngcontent-sc11="" class="syntax-all syntax-entity">InjectionToken</span>&lt;<span _ngcontent-sc11="" class="syntax-all syntax-constant">boolean</span>&gt;(<span _ngcontent-sc11="" class="syntax-all syntax-string">'Is server?'</span>, {
        factory() {
      <span _ngcontent-sc11="" class="syntax-all syntax-keyword">return</span> <span _ngcontent-sc11="" class="syntax-all syntax-entity">isPlatformServer</span>(<span _ngcontent-sc11="" class="syntax-all syntax-entity">inject</span>(<span _ngcontent-sc11="" class="syntax-all syntax-constant">PLATFORM_ID</span>));
        },
      });</code></pre><p _ngcontent-sc11=""> Create a structured directive using the <code _ngcontent-sc11="">IS_SERVER_PLATFORM</code> token with one simple target: render the component only on the server. </p><pre _ngcontent-sc11=""><code _ngcontent-sc11="" class="code-highlighted code-tsx">@<span _ngcontent-sc11="" class="syntax-all syntax-entity">Directive</span>({
        selector: <span _ngcontent-sc11="" class="syntax-all syntax-string">'[ifIsServer]'</span>,
      })
<span _ngcontent-sc11="" class="syntax-all syntax-keyword">export</span> <span _ngcontent-sc11="" class="syntax-all syntax-keyword">class</span> <span _ngcontent-sc11="" class="syntax-all syntax-entity">IfIsServerDirective</span> {
    <span _ngcontent-sc11="" class="syntax-all syntax-keyword">constructor</span>(
      @<span _ngcontent-sc11="" class="syntax-all syntax-entity">Inject</span>(<span _ngcontent-sc11="" class="syntax-all syntax-constant">IS_SERVER_PLATFORM</span>) <span _ngcontent-sc11="" class="syntax-all syntax-variable">isServer</span><span _ngcontent-sc11="" class="syntax-all syntax-keyword">:</span> <span _ngcontent-sc11="" class="syntax-all syntax-constant">boolean</span>,
      <span _ngcontent-sc11="" class="syntax-all syntax-variable">templateRef</span><span _ngcontent-sc11="" class="syntax-all syntax-keyword">:</span> <span _ngcontent-sc11="" class="syntax-all syntax-entity">TemplateRef</span>&lt;<span _ngcontent-sc11="" class="syntax-all syntax-constant">any</span>&gt;,
		<span _ngcontent-sc11="" class="syntax-all syntax-variable">viewContainer</span><span _ngcontent-sc11="" class="syntax-all syntax-keyword">:</span> <span _ngcontent-sc11="" class="syntax-all syntax-entity">ViewContainerRef</span>
	) {
		<span _ngcontent-sc11="" class="syntax-all syntax-keyword">if</span> (<span _ngcontent-sc11="" class="syntax-all syntax-parameter">isServer</span>) {
    <span _ngcontent-sc11="" class="syntax-all syntax-parameter">viewContainer</span>.<span _ngcontent-sc11="" class="syntax-all syntax-entity">createEmbeddedView</span>(<span _ngcontent-sc11="" class="syntax-all syntax-parameter">templateRef</span>);
		}
	}
}</code></pre><p _ngcontent-sc11="">The code looks similar to the <code _ngcontent-sc11="">IfIsBowser</code> directive.</p><p _ngcontent-sc11="">Now let's refactor the component:</p><pre _ngcontent-sc11=""><code _ngcontent-sc11="" class="code-highlighted code-tsx">@<span _ngcontent-sc11="" class="syntax-all syntax-entity">Component</span>({
    selector: <span _ngcontent-sc11="" class="syntax-all syntax-string">'ram-root'</span>,
	template: <span _ngcontent-sc11="" class="syntax-all syntax-string">'&lt;some-сomp *ifIsServer"&gt;&lt;/some-сomp&gt;'</span>,
	styleUrls: [<span _ngcontent-sc11="" class="syntax-all syntax-string">'./app.component.less'</span>],
})
<span _ngcontent-sc11="" class="syntax-all syntax-keyword">export</span> <span _ngcontent-sc11="" class="syntax-all syntax-keyword">class</span> <span _ngcontent-sc11="" class="syntax-all syntax-entity">AppComponent</span> {}</code></pre><p _ngcontent-sc11=""> Extra properties have been removed from the component. The component template is now a bit simpler. </p><p _ngcontent-sc11=""> Such directives declaratively hide and show content depending on the platform. </p><p _ngcontent-sc11=""> We have collected the tokens and directives in the package <code _ngcontent-sc11="">@ngx-ssr/platform</code>. </p><h2 _ngcontent-sc11="">5. Memory Leak</h2><h3 _ngcontent-sc11="">Situation</h3><p _ngcontent-sc11=""> At initialization, the service starts an interval and performs some actions. </p><pre _ngcontent-sc11=""><code _ngcontent-sc11="" class="code-highlighted code-tsx"><span _ngcontent-sc11="" class="syntax-all syntax-keyword">import</span> { <span _ngcontent-sc11="" class="syntax-all syntax-parameter">Injectable</span>, <span _ngcontent-sc11="" class="syntax-all syntax-parameter">NgZone</span> } <span _ngcontent-sc11="" class="syntax-all syntax-keyword">from</span> <span _ngcontent-sc11="" class="syntax-all syntax-string">"@angular/core"</span>;
<span _ngcontent-sc11="" class="syntax-all syntax-keyword">import</span> { <span _ngcontent-sc11="" class="syntax-all syntax-parameter">interval</span> } <span _ngcontent-sc11="" class="syntax-all syntax-keyword">from</span> <span _ngcontent-sc11="" class="syntax-all syntax-string">"rxjs"</span>;

@<span _ngcontent-sc11="" class="syntax-all syntax-entity">Injectable</span>()
<span _ngcontent-sc11="" class="syntax-all syntax-keyword">export</span> <span _ngcontent-sc11="" class="syntax-all syntax-keyword">class</span> <span _ngcontent-sc11="" class="syntax-all syntax-entity">LocationService</span> {
    <span _ngcontent-sc11="" class="syntax-all syntax-keyword">constructor</span>(<span _ngcontent-sc11="" class="syntax-all syntax-variable">ngZone</span><span _ngcontent-sc11="" class="syntax-all syntax-keyword">:</span> <span _ngcontent-sc11="" class="syntax-all syntax-entity">NgZone</span>) {
		<span _ngcontent-sc11="" class="syntax-all syntax-parameter">ngZone</span>.<span _ngcontent-sc11="" class="syntax-all syntax-entity">runOutsideAngular</span>(() <span _ngcontent-sc11="" class="syntax-all syntax-keyword">=&gt;</span> <span _ngcontent-sc11="" class="syntax-all syntax-entity">interval</span>(<span _ngcontent-sc11="" class="syntax-all syntax-constant">1000</span>).<span _ngcontent-sc11="" class="syntax-all syntax-entity">subscribe</span>(() <span _ngcontent-sc11="" class="syntax-all syntax-keyword">=&gt;</span> {
    <span _ngcontent-sc11="" class="syntax-all syntax-keyword">...</span>
		}));
	}
}</code></pre><p _ngcontent-sc11=""> This code does not affect the application's stability, but the callback passed to subscribe will continue to be called if the application is destroyed on the server. Each launch of the application on the server will leave behind an artifact in the form of an interval. And this is a potential memory leak. </p><h3 _ngcontent-sc11="">Possible Solution</h3><p _ngcontent-sc11=""> In our case, the problem is solved by using the ngOnDestoroy hook. It works for both components and services. We need to save the subscription and terminate it when the service is destructed. There are many techniques for unsubscribing, but here is just one: </p><pre _ngcontent-sc11=""><code _ngcontent-sc11="" class="code-highlighted code-tsx"><span _ngcontent-sc11="" class="syntax-all syntax-keyword">import</span> { <span _ngcontent-sc11="" class="syntax-all syntax-parameter">Injectable</span>, <span _ngcontent-sc11="" class="syntax-all syntax-parameter">NgZone</span>, <span _ngcontent-sc11="" class="syntax-all syntax-parameter">OnDestroy</span> } <span _ngcontent-sc11="" class="syntax-all syntax-keyword">from</span> <span _ngcontent-sc11="" class="syntax-all syntax-string">"@angular/core"</span>;
<span _ngcontent-sc11="" class="syntax-all syntax-keyword">import</span> { <span _ngcontent-sc11="" class="syntax-all syntax-parameter">interval</span>, <span _ngcontent-sc11="" class="syntax-all syntax-parameter">Subscription</span> } <span _ngcontent-sc11="" class="syntax-all syntax-keyword">from</span> <span _ngcontent-sc11="" class="syntax-all syntax-string">"rxjs"</span>;

@<span _ngcontent-sc11="" class="syntax-all syntax-entity">Injectable</span>()
<span _ngcontent-sc11="" class="syntax-all syntax-keyword">export</span> <span _ngcontent-sc11="" class="syntax-all syntax-keyword">class</span> <span _ngcontent-sc11="" class="syntax-all syntax-entity">LocationService</span> <span _ngcontent-sc11="" class="syntax-all syntax-keyword">implements</span> <span _ngcontent-sc11="" class="syntax-all syntax-entity">OnDestroy</span> {
    <span _ngcontent-sc11="" class="syntax-all syntax-keyword">private</span> subscription<span _ngcontent-sc11="" class="syntax-all syntax-keyword">:</span> <span _ngcontent-sc11="" class="syntax-all syntax-entity">Subscription</span>;

    <span _ngcontent-sc11="" class="syntax-all syntax-keyword">constructor</span>(<span _ngcontent-sc11="" class="syntax-all syntax-variable">ngZone</span><span _ngcontent-sc11="" class="syntax-all syntax-keyword">:</span> <span _ngcontent-sc11="" class="syntax-all syntax-entity">NgZone</span>) {
    <span _ngcontent-sc11="" class="syntax-all syntax-constant">this</span>.<span _ngcontent-sc11="" class="syntax-all syntax-parameter">subscription</span> <span _ngcontent-sc11="" class="syntax-all syntax-keyword">=</span> <span _ngcontent-sc11="" class="syntax-all syntax-parameter">ngZone</span>.<span _ngcontent-sc11="" class="syntax-all syntax-entity">runOutsideAngular</span>(() <span _ngcontent-sc11="" class="syntax-all syntax-keyword">=&gt;</span>
      <span _ngcontent-sc11="" class="syntax-all syntax-entity">interval</span>(<span _ngcontent-sc11="" class="syntax-all syntax-constant">1000</span>).<span _ngcontent-sc11="" class="syntax-all syntax-entity">subscribe</span>(() <span _ngcontent-sc11="" class="syntax-all syntax-keyword">=&gt;</span> {})
    );
  }

  ngOnDestroy()<span _ngcontent-sc11="" class="syntax-all syntax-keyword">:</span> <span _ngcontent-sc11="" class="syntax-all syntax-constant">void</span> {
    <span _ngcontent-sc11="" class="syntax-all syntax-constant">this</span>.<span _ngcontent-sc11="" class="syntax-all syntax-parameter">subscription</span>.<span _ngcontent-sc11="" class="syntax-all syntax-entity">unsubscribe</span>();
  }
}</code></pre><h2 _ngcontent-sc11="">6. Lack of rehydration</h2><h3 _ngcontent-sc11="">Situation</h3><p _ngcontent-sc11=""> The user's browser displays a page received from the server, a white screen flickers for a moment, and the application starts functioning and looks normal. </p><h3 _ngcontent-sc11="">Why is this happening</h3><p _ngcontent-sc11=""> Angular does not know how to reuse what it has rendered on the server. It strips all the HTML from the root element and starts painting all over again. </p><h3 _ngcontent-sc11="">Possible Solution</h3><p _ngcontent-sc11=""> It still doesn't exist. But there is hope that there will be a solution. Angular Universal's roadmap has a clause: "Full client rehydration strategy that reuses DOM elements/CSS rendered on the server". </p><h2 _ngcontent-sc11="">7. Inability to abort rendering</h2><h3 _ngcontent-sc11="">Situation</h3><p _ngcontent-sc11=""> We are catching a critical error. Rendering and waiting for stability are meaningless. You need to interrupt the process and give the client the default index.html. </p><h3 _ngcontent-sc11="">Why is this happening</h3><p _ngcontent-sc11=""> Let's go back to <a _ngcontent-sc11="" href="https://github.com/angular/angular/blob/11.1.x/packages/platform-server/src/utils.ts#L43">the moment of rendering the application</a>. It occurs when the application becomes stable. We can make our application stable faster using the solution from problem #1. But what if we want to abort the rendering process on the first caught error? What if we want to set a time limit on trying to render an application? </p><h3 _ngcontent-sc11="">Possible Solution</h3><p _ngcontent-sc11="">There is no solution to this problem now.</p><h1 _ngcontent-sc11="">Summary</h1><p _ngcontent-sc11=""> Angular Universal is the only supported and most widely used solution for rendering Angular applications on the server. The difficulty of integrating into an existing application depends largely on the developer. </p><p _ngcontent-sc11=""> There are still unresolved issues that don't allow me to classify Angular Universal as a production-ready solution. It is suitable for landing pages and static pages, but on complex applications, you can collect many problems, the solution of which will break in the blink of the page due to the lack of rehydration. </p></section></ikatsuba-root>
  <script src="runtime.70fa6f80178bac0e2313.js" defer=""></script><script src="polyfills.3dd1c5f9821ac67e1b54.js" defer=""></script><script src="main.bf6d9ec6bc017198c602.js" defer=""></script>


</body><!-- This page was prerendered with Angular Universal --></html>